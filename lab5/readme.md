# Контрольные вопросы

## 1. Рекурсивные структуры и их способы описания в Прологе

Рекурсивные структуры данных — это структуры, которые могут содержать сами себя в качестве компонентов. В Прологе такие структуры часто используются для представления списков, деревьев, графов и других сложных объектов.

**Способы описания рекурсивных структур:**

- **Через функторы:** Рекурсивные структуры определяются с помощью функторов, где один из аргументов может быть того же типа, что и сама структура. Например:
  ```prolog
  domains
      tree = empty; node(integer, tree, tree)
  ```

Здесь `tree` — это рекурсивная структура, представляющая двоичное дерево, где каждый узел содержит значение и два поддерева.

* **Через списки:** Списки в Прологе также являются рекурсивными структурами. Они состоят из головы (первого элемента) и хвоста (остальной части списка). Например:

```
domains
    list = integer*
```

**Через правила:** Рекурсивные структуры могут быть описаны через рекурсивные правила. Например, обход дерева можно реализовать так:

```
traverse(empty).
traverse(node(Value, Left, Right)) :-
    traverse(Left),
    write(Value), nl,
    traverse(Right).
```

## 2. Двоичные деревья и типичные операции над деревьями

 **Двоичное дерево** — это рекурсивная структура, где каждый узел содержит значение, левое поддерево и правое поддерево. Оно может быть пустым или непустым.

**Типичные операции:**

* **Проверка принадлежности элемента дереву:**

```
tree_member(X, tree(X, _, _)).
tree_member(X, tree(_, Left, _)) :- tree_member(X, Left).
tree_member(X, tree(_, _, Right)) :- tree_member(X, Right).
```

* **Обход дерева:**

  * **Сверху вниз:** Сначала обрабатывается корень, затем левое поддерево, потом правое.
  * **Слева направо:** Сначала левое поддерево, затем корень, потом правое.
  * **Снизу вверх:** Сначала левое и правое поддеревья, затем корень.
* **Вставка элемента в дерево:**

  ```
  insert(X, empty, tree(X, empty, empty)).
  insert(X, tree(Y, Left, Right), tree(Y, NewLeft, Right)) :-
      X < Y, insert(X, Left, NewLeft).
  insert(X, tree(Y, Left, Right), tree(Y, Left, NewRight)) :-
      X > Y, insert(X, Right, NewRight).
  ```

  ## 3. Упорядоченные деревья или справочники

  **Упорядоченное дерево (справочник) ** — это двоичное дерево, где значения в левом поддереве меньше значения в корне, а значения в правом поддереве больше.

  **Пример проверки упорядоченности:**


  ```
  ordered(empty).
  ordered(tree(X, Left, Right)) :-
      ordered(Left),
      ordered(Right),
      max_in_tree(Left, MaxLeft),
      min_in_tree(Right, MinRight),
      MaxLeft < X,
      X < MinRight.
  ```

  Здесь `max_in_tree` и `min_in_tree` — предикаты для поиска максимального и минимального значений в дереве.


## 4. Двоично-троичные справочники

 **Двоично-троичный справочник** — это расширение двоичного дерева, где каждый узел может иметь до трех потомков. Такие структуры полезны для более сложных задач, например, для представления троичной логики.

**Пример описания:**

```
domains
    ternary_tree = empty; node(integer, ternary_tree, ternary_tree, ternary_tree)
```

Здесь `node` имеет три поддерева вместо двух.

## 5. Описание n-ичных деревьев

 **n-ичное дерево** — это дерево, где каждый узел может иметь произвольное количество потомков. В Прологе это можно описать с помощью списков:

```
domains
    n_tree = empty; node(integer, list(n_tree))
```

Здесь `list(n_tree)` представляет список поддеревьев.

## 6. Способы задания графов и типовые операции над графами в Прологе

**Способы задания графов:**

1. **Через ребра:** Каждое ребро представлено как факт. Например:

   ```
   edge(a, b).
   edge(b, c).
   ```
2. **Через множества вершин и ребер:** Граф представлен как объект, содержащий множества вершин и ребер. Например:

   ```
   graph([a, b, c], [edge(a, b), edge(b, c)]).
   ```
3. **Через списки смежности:** Каждая вершина связана со списком смежных вершин. Например:

   ```
   adjacency_list([vertex(a, [b]), vertex(b, [a, c])]).
   ```

**Типовые операции:**

* Поиск пути между вершинами:

```**
path(X, Y) :- edge(X, Y).
path(X, Y) :- edge(X, Z), path(Z, Y).
```

* **Поиск циклов:**

  ```
  cycle(X) :- path(X, X).
  ```

  ## 7. Предикат отсечения в Прологе и его назначение

  **Предикат отсечения (`!`)** используется для ограничения пространства поиска решений. Он "фиксирует" текущее решение и отбрасывает все альтернативы.

  **Пример использования:**


  ```
  max(X, Y, X) :- X >= Y, !.
  max(_, Y, Y).
  ```

  Здесь отсечение гарантирует, что если первое правило выполнено, второе не будет проверяться.

## 8. Зеленые и красные отсечения


* **Зеленое отсечение:** Не изменяет множество решений программы. Просто оптимизирует поиск, отбрасывая ненужные альтернативы.

```
member(X, [X|_]) :- !.
member(X, [_|Tail]) :- member(X, Tail).
```

* **Красное отсечение:** Изменяет множество решений программы, что может привести к потере корректности.

  ```
  max(X, Y, X) :- X >= Y, !.
  max(_, Y, Y).
  ```

## 9. Достоинства и недостатки использования предиката отсечения

**Достоинства:**

* Ускоряет выполнение программы за счет уменьшения количества проверок.
* Позволяет контролировать процесс поиска решений.

**Недостатки:**

* Может нарушить декларативность программы, сделав её зависимой от порядка правил.
* Сложно отлаживать программы с отсечениями.

## 10. Отсечение и отрицание как неуспех

Отрицание в Прологе реализуется через предикат `\+`. Если цель не может быть доказана, она считается ложной. Отсечение часто используется вместе с отрицанием для контроля процесса вывода.

**Пример:**

```
not_member(X, List) :- \+ member(X, List).
```

Здесь `\+ member(X, List)` означает, что `X` не является членом списка.


## 11. Основные трудности в использовании отсечений и отрицаний

* **Потеря декларативности:** Программа становится процедурно зависимой, что затрудняет понимание её логики.
* **Ошибки при модификации:** Изменение одного правила может повлиять на работу других правил.
* **Сложность отладки:** Программы с отсечениями и отрицаниями сложно анализировать и тестировать.
