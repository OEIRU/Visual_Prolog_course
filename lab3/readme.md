# Контрольные вопросы

## 1. Назначение и правила использования в Пролог-программе секции `database`

Секция `database` в Прологе используется для объявления предикатов, которые будут представлять внутреннюю базу данных программы. Эти предикаты могут динамически изменяться во время выполнения программы (добавление, удаление фактов).

**Правила использования:**

- Факты можно добавлять и удалять, но нельзя добавлять правила.
- Факты не могут содержать свободные переменные.
- В программе может быть несколько секций `database`, но каждая должна иметь уникальное имя.
- Предикаты, объявленные в секции `database`, уникальны в пределах программы или модуля.
- Для работы с конкретной базой данных можно использовать имена секций.

---

## 2. Что такое стандартные (встроенные) предикаты? Перечислите предикаты работы с `database`.

Стандартные (встроенные) предикаты — это заранее определенные функции языка Пролог, которые предоставляют дополнительные возможности для управления программой, включая работу с базами данных.

**Предикаты работы с `database`:**

- `asserta/1`, `asserta/2` — добавление факта в начало базы данных.
- `assertz/1`, `assertz/2` — добавление факта в конец базы данных.
- `retract/1`, `retract/2` — удаление первого совпадающего факта.
- `retractall/1`, `retractall/2` — удаление всех совпадающих фактов.
- `consult/1`, `consult/2` — загрузка фактов из файла.
- `save/1`, `save/2` — сохранение фактов в файл.

---

## 3. Какой смысл имеют эти предикаты?

Эти предикаты позволяют динамически управлять внутренней базой данных программы:

- **`asserta` и `assertz`**: Добавляют новые факты в базу данных (в начало или конец соответственно).
- **`retract`**: Удаляет первый факт, соответствующий заданному шаблону.
- **`retractall`**: Удаляет все факты, соответствующие заданному шаблону.
- **`consult`**: Загружает факты из внешнего файла в базу данных.
- **`save`**: Сохраняет текущее состояние базы данных в файл.

---

## 4. Расскажите принцип работы этих предикатов.

- **`asserta` и `assertz`**: Эти предикаты добавляют новый факт в базу данных. `asserta` помещает факт перед существующими фактами, а `assertz` — после них. Если указан второй аргумент (имя базы данных), факт добавляется в соответствующую секцию.
- **`retract`**: Этот предикат удаляет первый факт, который унифицируется с заданным шаблоном. При поиске с возвратом он может удалить все совпадающие факты.
- **`retractall`**: Удаляет все факты, которые унифицируются с заданным шаблоном. Этот предикат всегда завершается успешно.
- **`consult`**: Считывает факты из файла и добавляет их в конец соответствующей секции базы данных. Если указан второй аргумент, факты загружаются только в указанную секцию.
- **`save`**: Сохраняет факты из указанной секции базы данных в файл. Файл создается в формате, который может быть загружен с помощью `consult`.

---

## 5. Как организовать цикл со счетчиком, используя базу данных?

Для организации цикла со счетчиком можно использовать факты базы данных как хранилище состояния счетчика. Например:

```prolog
% Инициализация счетчика
assert(counter(0)).

% Цикл
loop :-
    retract(counter(X)), % Получаем текущее значение счетчика
    X < 10,              % Проверяем условие
    NewX is X + 1,       % Увеличиваем счетчик
    assert(counter(NewX)), % Обновляем значение в базе данных
    write('Текущее значение: '), write(NewX), nl, % Выводим значение
    loop.                % Рекурсивный вызов

loop :-                  % Завершение цикла
    retract(counter(_)),  % Очищаем счетчик
    write('Цикл завершен.'), nl.
```

В этом примере счетчик хранится в базе данных как факт `counter/1`. На каждом шаге цикла значение счетчика увеличивается, обновляется в базе данных и выводится на экран.

## 6. Какие еще стандартные (встроенные) предикаты используются в данной работе? Объясните принцип их работы.

Кроме предикатов работы с базой данных, в лабораторной работе используются следующие стандартные предикаты:

* **`write/1`** : Выводит текст или значение переменной на экран.
  * Пример: `write('Привет, мир!')`.
* **`read/1`** : Считывает ввод пользователя и связывает его с переменной.
  * Пример: `read(X)` — считывает значение в переменную `X`.
* **`fail`** : Принудительно вызывает неудачу, что приводит к поиску альтернативных решений (если они есть).
* **Анонимная переменная `_` ** : Используется для игнорирования значений, которые не нужны в программе.

Пример использования:

```
dialog :-
    write('Введите ваше имя: '), read(Name),
    write('Привет, '), write(Name), nl,
    fail. % Вызывает повторный запуск диалога
```
