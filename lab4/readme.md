# Контрольные вопросы

## 1. Дайте определения списка. Как он представляется в Прологе и в Турбо-Прологе в частности?

**Список** — это рекурсивная структура данных, представляющая собой упорядоченную последовательность элементов. Список состоит из двух частей:

- **Голова (head)** — первый элемент списка.
- **Хвост (tail)** — оставшаяся часть списка, которая сама является списком.

В Прологе список представляется с помощью функтора `.(Head, Tail)`, где:

- `Head` — голова списка (первый элемент).
- `Tail` — хвост списка (оставшаяся часть).

Для удобства записи используется синтаксис `[Head | Tail]`. Например:

- Пустой список: `[]`.
- Список из одного элемента: `[a]` или `.(a, [])`.
- Список из нескольких элементов: `[a, b, c]` или `.(a, .(b, .(c, [])))`.

В Турбо-Прологе списки должны быть объявлены в разделе `DOMAINS`. Например:

```prolog
DOMAINS
    list = integer*  % список целых чисел

```

Здесь `list` — домен, представляющий список, а `integer*` указывает, что элементы списка имеют тип `integer`.

---

## 2. Какие абстрактные структуры данных можно моделировать с помощью списков?

Списки являются универсальной структурой данных и могут моделировать следующие абстрактные структуры:

* **Стек (Stack)** — реализуется через добавление и удаление элементов с одного конца списка (головы).
* **Очередь (Queue)** — реализуется через добавление элементов в конец списка и удаление с начала.
* **Множество (Set)** — список может представлять множество, если исключить повторяющиеся элементы.
* **Ассоциативный массив (Map)** — пары "ключ-значение" могут быть представлены как элементы списка.
* **Деревья (Tree)** — деревья можно моделировать с помощью вложенных списков, где каждый элемент представляет узел дерева.
* **Графы (Graph)** — графы можно представить как список ребер или список смежности.

---

## 3. Рекурсивные и итерационные алгоритмы обработки списков. Замена итерации рекурсией в Прологе. Преимущество итерационных алгоритмов перед рекурсивными алгоритмами.

### Рекурсивные алгоритмы

Рекурсивные алгоритмы обрабатывают список, разделяя его на голову и хвост. Обработка продолжается до тех пор, пока не будет достигнут пустой список (`[]`). Пример рекурсивного алгоритма для вычисления длины списка:

```
length([], 0).
length([_|Tail], N) :-
    length(Tail, N1),
    N is N1 + 1.
```

### Итерационные алгоритмы

Итерационные алгоритмы используют аккумулятор для накопления результата. В Прологе это реализуется через хвостовую рекурсию. Пример итерационного алгоритма для вычисления длины списка:

```
length(List, N) :-
    length_iter(List, 0, N).

length_iter([], Acc, Acc).
length_iter([_|Tail], Acc, N) :-
    NewAcc is Acc + 1,
    length_iter(Tail, NewAcc, N).
```

### Замена итерации рекурсией в Прологе

В Прологе отсутствует явная поддержка циклов, поэтому итерация заменяется рекурсией. Хвостовая рекурсия позволяет оптимизировать выполнение программы, так как компилятор может преобразовать её в итерацию.

### Преимущество итерационных алгоритмов

Итерационные алгоритмы (особенно хвостовая рекурсия) более эффективны, так как:

* Требуют меньше памяти (нет необходимости хранить стек вызовов).
* Быстрее выполняются за счет оптимизации компилятором.

---

## 4. Стандартные предикаты работы со списками

В Прологе существуют стандартные предикаты для работы со списками:


* **`member/2`** : Проверяет, является ли элемент членом списка.

```
member(X, [X|_]).
member(X, [_|Tail]) :- member(X, Tail).
```

* **`append/3`** : Объединяет два списка.

  ```
  append([], List, List).
  append([Head|Tail1], List2, [Head|Result]) :-
      append(Tail1, List2, Result).
  ```
* **`reverse/2`** : Переворачивает список.

  ```
  reverse(List, Reversed) :-
      reverse_iter(List, [], Reversed).

  reverse_iter([], Acc, Acc).
  reverse_iter([Head|Tail], Acc, Reversed) :-
      reverse_iter(Tail, [Head|Acc], Reversed).
  ```
* **`length/2`** : Вычисляет длину списка.

  ```
  length([], 0).
  length([_|Tail], N) :-
      length(Tail, N1),
      N is N1 + 1.
  ```
* **`findall/3` ** : Собирает все решения в список.

  ```
  findall(X, Goal, List).
  ```

  ## 5. Принцип работы алгоритма унификации. Какие основные операции обработки данных в процедурных языках включает в себя унификация?

  ### Принцип работы алгоритма унификации

  Унификация — это процесс сопоставления термов в Прологе. Она проверяет, можно ли сделать два терма одинаковыми путем подстановки значений переменных. Основные шаги:


  1. Если оба терма — константы, они должны быть равны.
  2. Если один терм — переменная, она связывается со значением другого терма.
  3. Если оба терма — структуры, их функторы и арности должны совпадать, а аргументы унифицируются рекурсивно.

```
?- X = 5, Y = X.
X = 5,
Y = 5.
```

### Основные операции обработки данных

Унификация включает в себя следующие операции, характерные для процедурных языков:

* **Присваивание** : Переменные связываются с значениями.
* **Сравнение** : Проверяется равенство термов.
* **Декомпозиция** : Разбор сложных структур на составляющие.
* **Подстановка** : Замена переменных на конкретные значения.
* **Объединение** : Создание новых структур данных.
