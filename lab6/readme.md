# Контрольные вопросы

## 1. Перечислите основные предикаты ввода-вывода. Почему эти предикаты называют внелогическими предикатами?

**Основные предикаты ввода:**

- `readln(X)` — чтение строки символов.
- `readint` — чтение целого числа.
- `readreal` — чтение вещественного числа.
- `readchar` — чтение символа.
- `readterm` — чтение составного объекта.

**Основные предикаты вывода:**

- `write(X)` — вывод значения переменной `X`.
- `writef(Format_string, X1, X2, ..., Xn)` — форматированный вывод.
- `nl` — переход на новую строку.

Эти предикаты называют **внелогическими**, потому что они порождают побочные эффекты (например, взаимодействие с внешним миром) и не соответствуют логической модели Пролога. В отличие от логических предикатов, которые могут быть истинными или ложными, предикаты ввода-вывода всегда детерминированы и не имеют альтернативных решений при возврате.

---

## 2. Приведите основную схему программы, работающей с файлами. Покажите, как эта схема реализована в Вашей программе.

**Основная схема работы с файлами:**

1. Открытие файла:
   - `openread/2`, `openwrite/2`, `openappend/2`, `openmodify/2`.
2. Переопределение устройства ввода/вывода:
   - `readdevice/1`, `writedevice/1`.
3. Чтение/запись данных:
   - `readln/1`, `write/1`, `writef/2`.
4. Закрытие файла:
   - `closefile/1`.

**Пример реализации:**

```prolog
domains
    file = myFile

predicates
    process_file
    read_and_process

clauses
    process_file :-
        openread(myFile, "input.txt"), % Открываем файл для чтения
        readdevice(myFile),           % Устанавливаем устройство ввода
        read_and_process,
        closefile(myFile).            % Закрываем файл

    read_and_process :-
        readln(Line),                 % Читаем строку
        Line = "",                    % Если строка пустая, завершаем
        !.
    read_and_process :-
        write(Line), nl,              % Выводим строку
        read_and_process.            % Рекурсивно обрабатываем следующую строку
```

## 3. Как осуществляется форматирование данных в Турбо-Прологе при вводе и выводе? Сравните с другими языками программирования

**Форматирование данных в Турбо-Прологе:**

* Используется предикат `writef/2`, который позволяет задавать формат вывода. Например:

  ```
  writef("Число: %d, Строка: %s\n", [42, "Пример"]).
  ```

  Здесь `%d` используется для целых чисел, `%s` — для строк.

**Сравнение с другими языками:**

* В языках, таких как C или Python, форматирование данных более гибкое. Например:
  * В C: `printf("Число: %d, Строка: %s\n", 42, "Пример");`
  * В Python: `print(f"Число: {42}, Строка: {'Пример'}")`.
* В Турбо-Прологе форматирование менее мощное, но достаточно для базовых задач.

## 4. Перечислите основные предикаты обработки строк.

**Основные предикаты обработки строк:**

* `frontchar(String1, Char, String2)` — разделяет строку на первый символ и остаток.
* `fronttoken(String1, Token, Rest)` — разделяет строку на первую лексему и остаток.
* `frontstr(Number_of_char, Startstr, Endstr)` — выделяет первые `Number_of_char` символов из строки.
* `concat(String1, String2, String3)` — объединяет две строки.
* `str_len(String, Length)` — вычисляет длину строки.

---

## 5. Рассмотрите логическую природу предикатов обработки строк. Какие ограничения накладывает реальная модель логического программирования, в частности Турбо-Пролога, на действия этих предикатов?

**Логическая природа предикатов:**

* Предикаты обработки строк полностью соответствуют логической модели Пролога. Они могут решать как прямые, так и обратные задачи. Например:

  ```
  frontchar("abc", Char, Rest). % Char = 'a', Rest = "bc"
  frontchar(String, 'a', "bc"). % String = "abc"
  ```
  **Ограничения:**

  * Реализация предикатов зависит от конкретной версии Пролога. Например, в Турбо-Прологе строки должны быть объявлены в доменах (`string` или `symbol`).
  * Некоторые предикаты могут быть недетерминированными, что требует осторожности при использовании.

  ---

  ## 7. Приведите примеры использования предикатов обработки строк в Вашей программе. Объясните, как действуют эти предикаты в данном случае.

  **Пример использования:**
* ```
  domains
      string = symbol

  predicates
      split_string(string, string, string)
      reverse_string(string, string)

  clauses
      % Разделение строки на первый символ и остаток
      split_string(Input, FirstChar, Rest) :-
          frontchar(Input, FirstChar, Rest).

      % Обращение строки
      reverse_string("", "").
      reverse_string(Input, Reversed) :-
          frontchar(Input, Char, Rest),
          reverse_string(Rest, TempReversed),
          concat(TempReversed, Char, Reversed).
  ```
  **Объяснение:**

  1. **`split_string/3`:**
     * Использует `frontchar/3` для разделения строки на первый символ (`FirstChar`) и остаток (`Rest`).
     * Пример: `split_string("abc", 'a', "bc")`.
  2. **`reverse_string/2`:**
     * Рекурсивно разбирает строку с помощью `frontchar/3`.
     * Использует `concat/3` для объединения символов в обратном порядке.
     * Пример: `reverse_string("abc", "cba")`.

  Эти предикаты демонстрируют логическую природу Пролога, где один и тот же предикат может использоваться для решения различных задач.
